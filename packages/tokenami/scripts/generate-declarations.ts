import fs from 'node:fs';
import * as supports from '../src/supports';

const properties = [...supports.supportedProperties];

const toPascalCase = (str: string) => {
  return str
    .split('-')
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join('');
};

// Generate pre-computed key types for each property (static parts + alias reference)
const keyTypes = properties
  .map((prop) => {
    const typeName = toPascalCase(prop) + 'Keys';
    return `type ${typeName} = Tokenami.TokenProperty<'${prop}'> | Tokenami.VariantProperty<'${prop}', string> | AliasedProperty<'${prop}'>;`;
  })
  .join('\n');

// Generate pre-computed value types for each property
const valueTypes = properties
  .map((prop) => {
    const typeName = toPascalCase(prop) + 'Value';
    return `type ${typeName} = PropertyThemeValue<'${prop}'>;`;
  })
  .join('\n');

// Generate property types using pre-computed keys and values
const propertyTypes = properties
  .map((prop) => {
    const typeName = toPascalCase(prop) + 'Properties';
    const keysType = toPascalCase(prop) + 'Keys';
    const valueType = toPascalCase(prop) + 'Value';
    return `type ${typeName} = { [K in ${keysType}]?: ${valueType} };`;
  })
  .join('\n');

// Generate SupportedTokenPropertiesMap entries
const mapEntries = properties
  .map((prop) => {
    const interfaceName = toPascalCase(prop) + 'Properties';
    return `  '${prop}': ${interfaceName};`;
  })
  .join('\n');

// Generate extends list for TokenamiProperties
const extendsEntries = properties.map((prop) => `${toPascalCase(prop)}Properties`).join(', ');

const fileContent = `// generated by ./scripts/generate-declarations.ts
import type * as CSS from 'csstype';
import type * as Tokenami from '@tokenami/config';

type Merge<A, B> = B extends never ? A : Omit<A, keyof B> & B;

// consumer will override this interface
interface TokenamiConfig {}
interface TokenamiFinalConfig extends Merge<Tokenami.Config, TokenamiConfig> {}

type ThemeConfig = TokenamiFinalConfig['theme'];
type AliasConfig = Omit<NonNullable<TokenamiFinalConfig['aliases']>, Tokenami.CSSProperty>;
type NativePropertyConfig = NonNullable<TokenamiFinalConfig['properties']>;
type CustomPropertyConfig = NonNullable<TokenamiFinalConfig['customProperties']>;
type ExperimentalProperty = Exclude<keyof NativePropertyConfig, keyof SupportedTokenPropertiesMap>;
type PropertyConfig = NativePropertyConfig & CustomPropertyConfig;
type AliasedProperties = keyof AliasConfig;
type CustomProperties = (keyof CustomPropertyConfig | ExperimentalProperty) extends \`\${infer K}\` ? K : never;

type Theme = ThemeConfig extends Tokenami.ThemeModes<infer T>
  ? T & ThemeConfig['root']
  : Omit<ThemeConfig, 'modes' | 'root'>;

/* -------------------------------------------------------------------------------------------------
 * Alias Resolution
 * -------------------------------------------------------------------------------------------------
 * AliasedPropertiesMap maps CSS property names to their alias-based keys.
 * For example, if aliases = { px: ['padding-left', 'padding-right'] }, then:
 * AliasedPropertiesMap['padding-left'] = '--px' | \`--\${string}_px\`
 * -----------------------------------------------------------------------------------------------*/

type AliasedPropertiesMap = {
  [A in AliasedProperties as AliasConfig[A][number]]: AliasKey<A>;
};

type AliasKey<A extends string> = Tokenami.TokenProperty<A> | Tokenami.VariantProperty<A, string>;

type AliasedProperty<P extends string> = P extends keyof AliasedPropertiesMap
  ? AliasedPropertiesMap[P]
  : never;

/* -------------------------------------------------------------------------------------------------
 * Property Value Resolution
 * -----------------------------------------------------------------------------------------------*/

type PropertyThemeValue<P extends string> = P extends keyof PropertyConfig
  ? NonNullable<PropertyConfig[P]>[number] extends \`\${infer ThemeKey}\`
    ? Tokenami.ArbitraryValue | CSS.Globals | TokenValue<ThemeKey>
    : never
  : P extends keyof Tokenami.CSSProperties ? Tokenami.CSSProperties[P] : never;

type TokenValue<ThemeKey extends string> =
  | (ThemeKey extends keyof TokensByThemeKey ? TokensByThemeKey[ThemeKey] : never)
  | (ThemeKey extends 'grid' | 'number' ? Tokenami.GridValue : never);

type TokensByThemeKey = {
  [K in keyof Theme]: keyof Theme[K] extends \`\${infer Token}\`
    ? Tokenami.TokenValue<K, Token>
    : never;
};

/* -------------------------------------------------------------------------------------------------
 * Pre-computed Key Types
 * -------------------------------------------------------------------------------------------------
 * Each property has pre-computed key types combining:
 * - Static base key: '--property-name'
 * - Static variant key: \`--\${string}_property-name\`
 * - Dynamic alias keys: AliasedProperty<'property-name'>
 * -----------------------------------------------------------------------------------------------*/

${keyTypes}

/* -------------------------------------------------------------------------------------------------
 * Pre-computed Value Types
 * -------------------------------------------------------------------------------------------------
 * Each property has a pre-computed value type to avoid repeated evaluation.
 * -----------------------------------------------------------------------------------------------*/

${valueTypes}

/* -------------------------------------------------------------------------------------------------
 * Property Types
 * -------------------------------------------------------------------------------------------------
 * Individual property types for use with Pick/Omit utilities.
 * -----------------------------------------------------------------------------------------------*/

${propertyTypes}

/* -------------------------------------------------------------------------------------------------
 * SupportedTokenPropertiesMap
 * -------------------------------------------------------------------------------------------------
 * Maps property names to their property types for Pick/Omit utilities.
 * -----------------------------------------------------------------------------------------------*/

interface SupportedTokenPropertiesMap {
${mapEntries}
}

/* -------------------------------------------------------------------------------------------------
 * Custom Properties
 * -----------------------------------------------------------------------------------------------*/

type CustomTokenamiProperties = {
  [C in CustomProperties as Tokenami.TokenProperty<C> | Tokenami.VariantProperty<C, string> | AliasedProperty<C>]?: PropertyThemeValue<C>;
};

/* -------------------------------------------------------------------------------------------------
 * TokenamiProperties
 * -----------------------------------------------------------------------------------------------*/

interface TokenamiProperties extends ${extendsEntries}, CustomTokenamiProperties {
  __tokenami__?: true;
  [customProperty: \`---\${string}\`]: any;
}

/* -------------------------------------------------------------------------------------------------
 * Utility Types
 * -----------------------------------------------------------------------------------------------*/

type TokenamiPropertiesPick<P extends keyof SupportedTokenPropertiesMap> = Pick<
  SupportedTokenPropertiesMap,
  P
> extends infer T
  ? T[keyof T]
  : never;

type TokenamiPropertiesOmit<P extends keyof SupportedTokenPropertiesMap> = Omit<
  SupportedTokenPropertiesMap,
  P
> extends infer T
  ? T[keyof T]
  : never;

export type {
  TokenamiConfig,
  TokenamiFinalConfig,
  TokenamiProperties,
  TokenamiPropertiesPick,
  TokenamiPropertiesOmit,
  TokenValue,
};
`;

fs.writeFileSync('./packages/tokenami/src/declarations.ts', fileContent);
console.log('File written successfully');
console.log('Total properties:', properties.length);
