import fs from 'node:fs';
import * as supports from '../src/supports';

const properties = [...supports.supportedProperties];

const toPascalCase = (str: string) => {
  return str
    .split('-')
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join('');
};

// Generate type aliases for each CSS property using TokenProperty<P> for keys
// These are simple mapped types with fast indexed lookups for values
const staticTypes = properties
  .map((prop) => {
    const typeName = toPascalCase(prop) + 'Properties';
    return `type ${typeName} = { [K in TokenProperty<'${prop}'>]?: PropertyThemeValue<'${prop}'> };`;
  })
  .join('\n');

// Generate SupportedTokenPropertiesMap entries
const mapEntries = properties
  .map((prop) => {
    const interfaceName = toPascalCase(prop) + 'Properties';
    return `  '${prop}': ${interfaceName};`;
  })
  .join('\n');

// Generate TokenamiProperties extends
const extendsEntries = properties.map((prop) => `${toPascalCase(prop)}Properties`).join(', ');

const fileContent = `// generated by ./scripts/generate-declarations.js
import type * as CSS from 'csstype';
import type * as Tokenami from '@tokenami/config';

type Merge<A, B> = B extends never ? A : Omit<A, keyof B> & B;

// consumer will override this interface
interface TokenamiConfig {}
interface TokenamiFinalConfig extends Merge<Tokenami.Config, TokenamiConfig> {}

type ThemeConfig = TokenamiFinalConfig['theme'];
type AliasConfig = Omit<NonNullable<TokenamiFinalConfig['aliases']>, Tokenami.CSSProperty>;
type NativePropertyConfig = NonNullable<TokenamiFinalConfig['properties']>;
type CustomPropertyConfig = NonNullable<TokenamiFinalConfig['customProperties']>;
type ExperimentalProperty = Exclude<keyof NativePropertyConfig, keyof SupportedTokenPropertiesMap>;
type PropertyConfig = NativePropertyConfig & CustomPropertyConfig;
type AliasedProperties = keyof AliasConfig;
type CustomProperties = (keyof CustomPropertyConfig | ExperimentalProperty) extends \`\${infer K}\` ? K : never;

type Theme = ThemeConfig extends Tokenami.ThemeModes<infer T>
  ? T & ThemeConfig['root']
  : Omit<ThemeConfig, 'modes' | 'root'>;

type AliasedPropertiesMap = {
  [A in AliasedProperties as AliasConfig[A][number]]: Property<A>
};

type AliasedProperty<P> = P extends keyof AliasedPropertiesMap ? AliasedPropertiesMap[P] : never

type TokenProperty<P> = P extends string
  ? AliasedProperty<P> | Property<P>
  : never

type Property<P extends string> =
  | Tokenami.TokenProperty<P>
  | Tokenami.VariantProperty<P, string>;

type PropertyThemeValue<P> = P extends keyof PropertyConfig
  ? NonNullable<PropertyConfig[P]>[number] extends \`\${infer ThemeKey}\`
    ? Tokenami.ArbitraryValue | CSS.Globals | TokenValue<ThemeKey>
    : never
  : P extends keyof Tokenami.CSSProperties ? Tokenami.CSSProperties[P] : never;

type TokenValue<ThemeKey extends string> =
  | (ThemeKey extends keyof TokensByThemeKey ? TokensByThemeKey[ThemeKey] : never)
  | (ThemeKey extends 'grid' | 'number' ? Tokenami.GridValue : never);

type TokensByThemeKey = {
  [K in keyof Theme]: keyof Theme[K] extends \`\${infer Token}\`
    ? Tokenami.TokenValue<K, Token>
    : never;
};

${staticTypes}

interface SupportedTokenPropertiesMap {
${mapEntries}
}

type CustomTokenamiProperties = {
  [C in CustomProperties as TokenProperty<C>]?: PropertyThemeValue<C>;
};

interface TokenamiProperties extends CustomTokenamiProperties, ${extendsEntries} {
  __tokenami__?: true;
  [customProperty: \`---\${string}\`]: any;
}

type TokenamiPropertiesPick<P extends keyof SupportedTokenPropertiesMap> = Pick<
  SupportedTokenPropertiesMap,
  P
> extends infer T
  ? T[keyof T]
  : never;

type TokenamiPropertiesOmit<P extends keyof SupportedTokenPropertiesMap> = Omit<
  SupportedTokenPropertiesMap,
  P
> extends infer T
  ? T[keyof T]
  : never;

export type {
  TokenamiConfig,
  TokenamiFinalConfig,
  TokenamiProperties,
  TokenamiPropertiesPick,
  TokenamiPropertiesOmit,
  TokenValue,
};
`;

fs.writeFileSync('./packages/tokenami/src/declarations.ts', fileContent);
console.log('File written successfully');
console.log('Total properties:', properties.length);
